作用域：
    局部作用域：
        函数作用域：函数内部声明（外部无法访问）
        块作用域：大括号内部声明（var声明的不会产生，let和const声明的会产生）
    全局作用域：最外层变量

垃圾回收：
    引用计数法：已弃用（两个对象相互引用，无法回收，内存泄漏）
    标记清除法：全局寻找（从根部扫描，找不到就回收）

闭包：一个函数对周围状态的引用捆绑在一起，内层函数中访问到外层函数作用域（内层函数+外层函数的变量）
    作用：外部访问函数内部变量，实现数据私有（声明一个fu，返回一个fn）
    风险：内存泄漏

变量提升：（仅存在与var声明的变量）将变量声明（不提升赋值）提升到当前作用域最前面
    var：变量（函数作用域，变量提升，可重复声明）
    let：变量（块级作用域，没有变量提升，作用域仅可声明一次）
    const：常量（块级作用域，命名全大写，一定要赋初始值，可以修改数组和对象的元素）

函数提升：将函数声明提升到当前作用域最前面（只提升函数声明，不提升调用），函数表达式必须先声明赋值才能调用

函数参数：
    动态参数：不写参数，使用arguments（伪数组）
    剩余参数：获取多余实参（真数组）
    展开运算符（...）:展开数组，不会修改原数组（取最大最小值，合并数组）

必须加分号的两种情况：
    立即执行函数：(function(){})();
    使用数组的时候

箭头函数：
    this静态，存在于声明函数作用域
    不能作为构造函数实例化对象
    不能使用arguments对象

Symble(类似字符串的第七种基本数据类型):给对象添加属性方法
    值是唯一的
    不能与其他数据进行运算
    不能遍历

生成器（函数）：异步编程

Promise(构造函数):封装异步操作并获取成功或者失败的结果

async（函数前缀）：
    返回结果不是Promise对象，返回成功的Promise对象
    抛出错误返回失败的Promise
    返回结果是一个Promise对象，结构看Promise对象

await:
    必须写在async函数中
    右侧表达式一般为Promise对象
    返回成功的值，失败了抛出异常

原型对象：利用原型对象实现方法共享（构造函数属性）
    每一个构造函数都有一个prototype属性，指向另一个对象
    可以吧不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法
    构造函数和原型对象中的this都指向实例化的对象

    constructor(构造函数)：
        每一个原型对象都有该属性，指向构造函数 
        重新指回创造这个原型对象的构造函数

对象原型（__proto__）：指向该构造函数的原型对象（实例对象属性）
    只读，取不到，用来表明当前实例对象指向那个原型对象
    里面有个 constructor 属性，指向该实例对象的构造函数


原型链：查找规则
    只要是对象就有对象原型
    只要是原型对象就有构造函数
    原型对象也有对象原型

深浅拷贝（之针对引用数据类型）：
    浅拷贝：简单数据拷贝值，引用类型拷贝地址 （展开运算符），单层使用不受影响，适用简单数据类型
    深拷贝：拷贝对象
        实现方式：
            递归
            lodash/cloneDeep
            JSON.stringify()

this:
    普通函数：谁调用指向谁
    箭头函数：不存在this（不适用构造函数，原型对象）

    改变指向:
        call:fn.call(thisArg,ages1,ages2)
        apply:fn.applt(thisArg,[argsArray ])
        bind(不会调用函数,返回新函数):fn.bind(thisArg,ages1,ages2)

防抖：单位时间内，频繁触发事件只执行最后一次（搜索框搜索输入、邮箱验证输入检测）（回城）
节流(throttle)：单位时间内，频繁触发事件只执行一次（高频事件）（放技能）